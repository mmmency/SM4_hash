#include<bits/stdc++.h>
using namespace std;
vector<int> X;//8*64=512，每个下标存放8位
int Turn;//加密分组数量
int A[64],B[64],K[64],Ciph[64];//k为密钥
int subK[11][64]; //11个轮密钥
int S[256]={ //S盒
0x68,0x10,0xeb,0x2b,0x48,0x9d,0x6a,0xe4,
0xe3,0xa3,0x56,0x81,0x7d,0xf1,0x85,0x93,
0x2c,0x8e,0x78,0xca,0x17,0xa9,0x61,0xd5,
0x5d,0x0b,0x8c,0x3c,0x77,0x51,0x22,0x42,
0x3f,0x54,0x41,0x80,0xcc,0x86,0xb3,0x18,
0x2e,0x57,0x06,0x62,0xf4,0x36,0xd1,0x6b,
0x1b,0x65,0x75,0x10,0xda,0x49,0x26,0xf9,
0xcb,0x66,0xe7,0xba,0xae,0x50,0x52,0xab,
0x05,0xf0,0x0d,0x73,0x3b,0x04,0x20,0xfe,
0xdd,0xf5,0xb4,0x5f,0x0a,0xb5,0xc0,0xa0,
0x71,0xa5,0x2d,0x60,0x72,0x93,0x39,0x08,
0x83,0x21,0x5c,0x87,0xb1,0xe0,0x00,0xc3,
0x12,0x91,0x8a,0x02,0x1c,0xe6,0x45,0xc2,
0xc4,0xfd,0xbf,0x44,0xa1,0x4c,0x33,0xc5,
0x84,0x23,0x7c,0xb0,0x25,0x15,0x35,0x69,
0xff,0x94,0x4d,0x70,0xa2,0xaf,0xcd,0xd6,
0x6c,0xb7,0xf8,0x09,0xf3,0x67,0xa4,0xea,
0xec,0xb6,0xd4,0xd2,0x14,0x1e,0xe1,0x24,
0x38,0xc6,0xdb,0x4b,0x7a,0x3a,0xde,0x5e,
0xdf,0x95,0xfc,0xaa,0xd7,0xce,0x07,0x0f,
0x3d,0x58,0x9a,0x98,0x9c,0xf2,0xa7,0x11,
0x7e,0x8b,0x43,0x03,0xe2,0xdc,0xe5,0xb2,
0x4e,0xc7,0x6d,0xe9,0x27,0x40,0xd8,0x37,
0x92,0x8f,0x01,0x1d,0x53,0x3e,0x59,0xc1,
0x4f,0x32,0x16,0xfa,0x74,0xfb,0x63,0x9f,
0x34,0x1a,0x2a,0x5a,0x8d,0xc9,0xcf,0xf6,
0x90,0x28,0x88,0x9b,0x31,0x0e,0xbd,0x4a,
0xe8,0x96,0xa6,0x0c,0xc8,0x79,0xbc,0xbe,
0xef,0x6e,0x46,0x97,0x5b,0xed,0x19,0xd9,
0xac,0x99,0xa8,0x29,0x64,0x1f,0xad,0x55,
0x13,0xbb,0xf7,0x6f,0xb9,0x47,0x2f,0xee,
0xb8,0x7b,0x89,0x30,0xd3,0x7f,0x76,0x82
};
int C[64]={//θ变换用到的数组C
1,1,3,1,5,8,9,5,
5,1,1,3,1,5,8,9,
9,5,1,1,3,1,5,8,
8,9,5,1,1,3,1,5,
5,8,9,5,1,1,3,1,
1,5,8,9,5,1,1,3,
3,1,5,8,9,5,1,1,
1,3,1,5,8,9,5,1
};
void printX() {//输出填充后的文本
    printf("\n明文填充后为：\n");
    for (int i = 0; i < X.size(); i++) {
        printf("%02x", X[i]);
        if ((i + 1) % 4 == 0)
            printf(" ");
        if ((i + 1) % 16 == 0)
            printf("\n");
    }
}

void printC(int T[64]){  //输出512位
    for(int i=0;i<64;i++) printf("%02x",T[i]);
}

void append(string m) {//文本的填充处理
    Turn = (m.size() + 32) / 64 + 1;//32*8=256为填充长度的预留位
    X.resize(Turn * 64);  //Turn为分组数 一组512bit 为64个十六进制
    int i = 0;
    for (; i < m.size(); i++) {
        X[i] = m[i];
    }
    X[i++] = 0x80;
    while (i < X.size() - 32) {
        X[i] = 0;
        i++;
    }
    long long int a = m.size() * 8;  //明文长度
    for (i = X.size() - 1; i >= X.size() - 32; i--) {
        X[i] = a % 256;
        a /= 256;
    }
}

void appendKey(string m){  //当密钥位数不够时用0扩充
    if(m.size()>63){
        cout<<"密钥应为512位！"<<endl;
        return;
    }
    int i=0;
    for(;i<m.size();i++) K[i]=m[i];
    for(;i<64;i++) K[i]=0;
}

void r_transform(int a[64],int b[64]){//r变换，S盒
    for(int i=0;i<64;i++) b[i]=S[a[i]];
    memcpy(a,b,sizeof(int)*64);
}

void column_transform(int a[64],int b[64]){//列循环变换
    for(int i=0;i<8;i++){
        for(int j=0;j<8;j++) b[8*j+i]=a[((j-i+8)%8)*8+i];
    }
    memcpy(a,b,sizeof(int)*64);
}

void row_mixture(int a[64],int b[64]){//线性扩散变换
    for(int i=0;i<8;i++)
        for(int j=0;j<8;j++){
            b[8*i+j]=0;
            for(int k=0;k<8;k++)b[8*i+j]+=a[8*i+k]*C[8*k+j];
            b[8*i+j]%=256;
        }
    memcpy(a,b,sizeof(int)*64);
}

void add_subkey(int n,int a[64],int b[64]){//密钥加法
    for(int i=0;i<64;i++) b[i]=a[i]^subK[n][i];
    memcpy(a,b,sizeof(int)*64);
}

void one_round(int n,int a[64],int b[64]){ //轮函数
    r_transform(a,b);
    column_transform(a,b);
    row_mixture(a,b);
    add_subkey(n,a,b);
}

void create_subkey(){  //子密钥导出
    for(int i=0;i<64;i++) subK[0][i]=K[i];
    int Con[64];  //轮常数
    for(int r=1;r<11;r++){
        for(int i=0;i<8;i++)
            for(int j=0;j<8;j++){
                if(i==0) Con[8*i+j]=S[8*(r-1)+j];
                else Con[8*i+j]=0x00;
            }
        one_round(r-1,Con,subK[r]);
    }
}

int main(){
    string str,strk;//明文
    cout<<"请输入明文：";
    cin>>str;
    cout<<"请输入密钥：";
    cin>>strk;
    append(str);  //填充明文
    appendKey(strk);  //填充初始密钥
    create_subkey(); //导出轮密钥
    cout<<"完整密钥为："<<endl;
    printC(K); //输出密钥
    printX();  //输出填充后的文本
    for(int i=0;i<64;i++) Ciph[i]=0x00;
    for(int i=0;i<Turn;i++){
        for(int j=0;j<64;j++) A[j]=X[i*64+j];
        for(int R=0;R<11;R++) one_round(R,A,B);
        for(int j=0;j<64;j++) Ciph[j]^=A[j];
    }
    cout<<"密文为："<<endl;
    printC(Ciph); //输出密文
    return 0;
}